function [Mhat,Khat] = infer_diffusion(C_train, u_train, h, Ahat, Nhat)

%Inputs--------------------------
% C_train: each cell contains the covariance of the reduced states
% C_r(t) = cov(Xr, Xr) = Vr^T * cov(X, X) * Vr -> R^{r x r}
% u_train: input matrix 
% h: sampling time dt
% Ahat: linear reduced operator, inferred from drift OpInf
% Nhat: bilinear reduced operator, inferred from drift OpInf

%Outputs--------------------------
% Mhat: reduced diffustion matrix 
% Khat: reduced covariance matrix 
% -> Hhat = Mhat * Khat * Mhat^T (diffusion contribution)
%---------------------------------

m = size(u_train{1}, 1);
p = numel(u_train);

% The solution of the least squares problem is the mean over the residuals 
Hhat = zeros(size(Ahat));

% loop over each trajectory
for ii=1:p
  [Cr, Cr_dot, ind] = central_finite_differences(C_train{ii}, h, 2, 3);
  u = u_train{ii};

  for jj=1:numel(ind)
    % Clyap: \Psi_r(t) * Cr(t) in the paper..
    Psi_hat = Ahat + Nhat * kron( u(:,jj), eye(m) );
    Clyap = Psi_hat * Cr(:,:,jj);
    
    Hhat = Hhat + 1/(p*numel(ind))*(Cr_dot(:,:,jj) - Clyap - Clyap'); 
  end
end

% make sure that the H is symmetric
Hhat = Hhat/2+Hhat'/2;

% get Eigendecomposition of H and sort
[HU,HS] = eig(Hhat);
[Ssort,I] = sort(diag(HS),'descend');
HS = diag(Ssort);
HU = HU(:,I);

% get the index of the last singular value that is greater or equal
% than tol*\sigma_max: (corresponds to 2-norm)
tol = max(HS,[],'all')/1000;
d = find(diag(HS)>= tol,1,'last');
if isempty(d)
  d=0;
end

% truncate H and decompose
Mhat = HU(:,1:d) * sqrt(HS(1:d,1:d));
Khat = eye(d);
end

